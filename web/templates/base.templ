package templates

import "github.com/emiliopalmerini/due-draghi-5e-srd/internal/adapters/web/models"

templ BaseLayout(data models.PageData) {
	<!DOCTYPE html>
	<html lang="it">
	<head>
		<meta charset="utf-8"/>
		<title>
			if data.Title != "" {
				{ data.Title }
			} else {
				Quinta Edizione.online
			}
		</title>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<script src="https://unpkg.com/htmx.org@2.0.3"></script>
		<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
		<link rel="stylesheet" href="/static/style.css"/>
		<link rel="icon" href="/static/favicon.svg" type="image/svg+xml"/>
	</head>
	<body style="min-height: 100vh; display: flex; flex-direction: column; background: var(--notion-bg); color: var(--notion-text);">
		<!-- Notion-style top bar -->
		<header class="notion-nav">
			<div class="notion-nav-container">
				<nav class="breadcrumb" aria-label="Breadcrumb">
					<a href="/" class="btn">Home</a>
					if data.Collection != "" {
						<span style="color: var(--notion-text-light);">/</span>
						if data.QueryString != "" {
							<a href={ templ.URL("/" + data.Collection + "?" + data.QueryString) } class="btn">{ data.Collection }</a>
						} else {
							<a href={ templ.URL("/" + data.Collection) } class="btn">{ data.Collection }</a>
						}
						<span class="breadcrumb-separator">/</span>
						<div class="search-container">
							<input id="bc-search" name="q" 
								if data.DocTitle != "" { 
									placeholder={ data.DocTitle } 
								} else if data.DocID != "" { 
									placeholder={ data.DocID } 
								} else { 
									placeholder={ "Cerca in " + data.Collection + "…" } 
								}
								class="field" style="width: 240px; font-size: 13px; padding: 6px 10px;"
								hx-get={ "/quicksearch/" + data.Collection }
								hx-target="#bc-results"
								hx-trigger="keyup changed delay:200ms"
								autocomplete="off" aria-controls="bc-results" aria-expanded="false"/>
							<div id="bc-results" class="search-results hidden" 
								role="listbox" aria-label="Risultati ricerca rapida"></div>
						</div>
					}
					if data.DocTitle != "" && data.Collection == "" {
						<span style="color: var(--notion-text-light);">/</span>
						<span style="color: var(--notion-text); font-weight: 500; max-width: 40vw;" class="truncate" title={ data.DocTitle }>{ data.DocTitle }</span>
					} else if data.DocID != "" && data.Collection == "" {
						<span style="color: var(--notion-text-light);">/</span>
						<span class="mono tag" title={ data.DocID }>{ data.DocID }</span>
					}
				</nav>
			</div>
		</header>

		<!-- Notion-style content area -->
		<main style="flex: 1; background: var(--notion-bg);">
			<div id="page-root" hx-history-elt class="container" style="max-width: 1024px; padding-top: 2rem; padding-bottom: 2rem;">
				{ children... }
				<div id="page-loading" class="page-overlay" aria-hidden="true">
					<div class="page-overlay-inner">
						<span class="spinner"></span>
					</div>
				</div>
			</div>
		</main>

		@legalFooter()

		@baseScripts()
	</body>
	</html>
}

templ baseScripts() {
	<script>
		// Minimal JavaScript for Markdown rendering and clipboard
		function initMarkdown(){
			const hasMarked = typeof window.marked !== 'undefined';
			if (hasMarked && window.marked.setOptions){
				try { window.marked.setOptions({ headerIds: true, mangle: false }); } catch(e) {}
			}
			document.querySelectorAll('[data-markdown]').forEach(el=>{
				if (el.getAttribute('data-ssr') === 'true') return;
				let raw = '';
				const srcId = el.getAttribute('data-md-src-id');
				if (srcId){
					const src = document.getElementById(srcId);
					if (src) raw = src.textContent || '';
				}
				if (!raw){ raw = el.textContent || ''; }
				el.dataset.raw = raw;
				if(hasMarked){ el.innerHTML = window.marked.parse(raw); }
			});
		}
		document.addEventListener('DOMContentLoaded', initMarkdown);
		document.body.addEventListener('htmx:afterSwap', initMarkdown);

		// Copy markdown functionality with fallback support
		function copyMarkdown(btn){
			const section = btn.closest('[data-md-section]') || btn.closest('article') || document;
			let md = section.querySelector('[data-markdown]');
			if (!md) md = section.querySelector('[data-ssr="true"]');
			const raw = (md && (md.dataset.raw || md.getAttribute('data-raw') || md.textContent)) || '';
			
			if(!raw) {
				showCopyMessage(btn, 'Nessun contenuto da copiare', 'error');
				return;
			}
			
			// Try modern clipboard API first
			if (navigator.clipboard && navigator.clipboard.writeText) {
				navigator.clipboard.writeText(raw).then(() => {
					showCopyMessage(btn, 'Copiato', 'success');
				}).catch(() => {
					// Fallback to legacy method if modern API fails
					copyToClipboardFallback(raw, btn);
				});
			} else {
				// Use fallback method for browsers without clipboard API
				copyToClipboardFallback(raw, btn);
			}
		}

		// Fallback copy method using document.execCommand
		function copyToClipboardFallback(text, btn) {
			try {
				// Create temporary textarea element
				const textarea = document.createElement('textarea');
				textarea.value = text;
				textarea.style.position = 'fixed';
				textarea.style.left = '-9999px';
				textarea.style.top = '-9999px';
				textarea.style.opacity = '0';
				textarea.setAttribute('readonly', '');
				
				document.body.appendChild(textarea);
				
				// Select and copy text
				textarea.select();
				textarea.setSelectionRange(0, textarea.value.length);
				
				const successful = document.execCommand('copy');
				document.body.removeChild(textarea);
				
				if (successful) {
					showCopyMessage(btn, 'Copiato', 'success');
				} else {
					// Final fallback: select text for manual copy
					showSelectableText(text, btn);
				}
			} catch (err) {
				// Final fallback: show selectable text
				showSelectableText(text, btn);
			}
		}

		// Show copy message with different types
		function showCopyMessage(btn, message, type = 'success') {
			// Remove any existing messages
			const existingMessage = btn.nextElementSibling;
			if (existingMessage && existingMessage.className.includes('flash-message')) {
				existingMessage.remove();
			}
			
			const flash = document.createElement('span');
			flash.className = `flash-message flash-${type}`;
			flash.textContent = message;
			btn.insertAdjacentElement('afterend', flash);
			setTimeout(() => flash.remove(), type === 'error' ? 3000 : 1200);
		}

		// Final fallback: show text in a modal for manual selection
		function showSelectableText(text, btn) {
			const modal = document.createElement('div');
			modal.className = 'copy-text-modal';
			modal.innerHTML = `
				<div class="copy-text-modal-content">
					<div class="copy-text-header">
						<h3>Seleziona e copia il testo</h3>
						<button onclick="this.closest('.copy-text-modal').remove()" class="copy-text-close">×</button>
					</div>
					<textarea readonly class="copy-text-area">${text}</textarea>
					<div class="copy-text-footer">
						<small>Seleziona tutto il testo (Ctrl+A) e copialo (Ctrl+C)</small>
					</div>
				</div>
			`;
			
			document.body.appendChild(modal);
			
			// Auto-select text and focus textarea
			const textarea = modal.querySelector('.copy-text-area');
			setTimeout(() => {
				textarea.focus();
				textarea.select();
			}, 100);
			
			// Close modal on background click
			modal.addEventListener('click', function(e) {
				if (e.target === modal) {
					modal.remove();
				}
			});
			
			// Close modal on Escape key
			document.addEventListener('keydown', function escapeHandler(e) {
				if (e.key === 'Escape') {
					modal.remove();
					document.removeEventListener('keydown', escapeHandler);
				}
			});
		}

		// Keyboard navigation shortcuts
		function initKeyboardNavigation() {
			document.addEventListener('keydown', function(e) {
				// Don't interfere when user is typing in inputs
				if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.contentEditable === 'true') {
					// Allow Escape to blur input fields
					if (e.key === 'Escape') {
						e.target.blur();
					}
					return;
				}

				// Navigation shortcuts
				switch(e.key) {
					case '/':
						// Focus search input
						e.preventDefault();
						const searchInput = document.querySelector('#q, #bc-search');
						if (searchInput) {
							searchInput.focus();
							searchInput.select();
						}
						break;

					case 'ArrowLeft':
					case 'h':
						// Previous item
						e.preventDefault();
						const prevLink = document.querySelector('a[href*="/"][hx-get*="/"] [class*="precedente"], a[href*="/"] .htmx-indicator + span:contains("Precedente")');
						const prevBtn = prevLink ? prevLink.closest('a') : document.querySelector('a[href]:has-text("Precedente"), a[href]:has-text("← Precedente")');
						if (prevBtn && !prevBtn.style.pointerEvents.includes('none')) {
							prevBtn.click();
						}
						break;

					case 'ArrowRight':
					case 'l':
						// Next item
						e.preventDefault();
						const nextLink = document.querySelector('a[href*="/"][hx-get*="/"] [class*="successivo"], a[href*="/"] .htmx-indicator + span:contains("Successivo")');
						const nextBtn = nextLink ? nextLink.closest('a') : document.querySelector('a[href]:has-text("Successivo"), a[href]:has-text("Successivo →")');
						if (nextBtn && !nextBtn.style.pointerEvents.includes('none')) {
							nextBtn.click();
						}
						break;

					case 'u':
					case 'ArrowUp':
						// Go up (back to collection)
						e.preventDefault();
						const backLink = document.querySelector('a[href]:has-text("Lista"), a[href]:has-text("← Lista")');
						if (backLink) {
							backLink.click();
						}
						break;

					case 'Home':
					case 'g':
						// Go home
						e.preventDefault();
						window.location.href = '/';
						break;

					case '?':
						// Show keyboard shortcuts help
						e.preventDefault();
						showKeyboardHelp();
						break;
				}
			});
		}

		// Show keyboard shortcuts help
		function showKeyboardHelp() {
			const helpText = `
				Scorciatoie da tastiera:
				
				/          - Cerca
				← o h      - Elemento precedente
				→ o l      - Elemento successivo  
				↑ o u      - Torna alla lista
				Home o g   - Vai alla home
				Esc        - Chiudi ricerca
				?          - Mostra questa guida
			`;
			
			// Create modal
			const modal = document.createElement('div');
			modal.className = 'keyboard-help-modal';
			modal.innerHTML = `
				<div class="keyboard-help-content">
					<h3>Scorciatoie da Tastiera</h3>
					<div class="keyboard-shortcuts">
						<div><kbd>/</kbd> <span>Cerca</span></div>
						<div><kbd>←</kbd> o <kbd>h</kbd> <span>Elemento precedente</span></div>
						<div><kbd>→</kbd> o <kbd>l</kbd> <span>Elemento successivo</span></div>
						<div><kbd>↑</kbd> o <kbd>u</kbd> <span>Torna alla lista</span></div>
						<div><kbd>Home</kbd> o <kbd>g</kbd> <span>Vai alla home</span></div>
						<div><kbd>Esc</kbd> <span>Chiudi ricerca/guida</span></div>
						<div><kbd>?</kbd> <span>Mostra questa guida</span></div>
					</div>
					<button onclick="this.closest('.keyboard-help-modal').remove()">Chiudi</button>
				</div>
			`;
			
			document.body.appendChild(modal);
			
			// Close on Escape or click outside
			modal.addEventListener('click', function(e) {
				if (e.target === modal) modal.remove();
			});
			
			document.addEventListener('keydown', function closeOnEscape(e) {
				if (e.key === 'Escape') {
					modal.remove();
					document.removeEventListener('keydown', closeOnEscape);
				}
			});
		}

		document.addEventListener('DOMContentLoaded', initKeyboardNavigation);

		// Breadcrumb search functionality
		function initBreadcrumbSearch() {
			const searchInput = document.getElementById('bc-search');
			const searchResults = document.getElementById('bc-results');
			
			if (!searchInput || !searchResults) return;
			
			// Show results when typing
			searchInput.addEventListener('input', function() {
				if (this.value.trim().length > 0) {
					searchResults.classList.remove('hidden');
					searchResults.setAttribute('aria-expanded', 'true');
				} else {
					searchResults.classList.add('hidden');
					searchResults.setAttribute('aria-expanded', 'false');
				}
			});
			
			// Hide results when clicking outside
			document.addEventListener('click', function(e) {
				const searchContainer = searchInput.closest('.search-container');
				if (searchContainer && !searchContainer.contains(e.target)) {
					searchResults.classList.add('hidden');
					searchResults.setAttribute('aria-expanded', 'false');
				}
			});
			
			// Handle keyboard navigation in search input
			searchInput.addEventListener('keydown', function(e) {
				const results = searchResults.querySelectorAll('.search-result');

				if (e.key === 'Escape') {
					searchResults.classList.add('hidden');
					searchResults.setAttribute('aria-expanded', 'false');
					this.blur();
				} else if (e.key === 'ArrowDown' && results.length > 0) {
					e.preventDefault();
					results[0].focus();
				} else if (e.key === 'Enter') {
					e.preventDefault();
					// If there are search results, click the first one
					if (results.length > 0) {
						const firstResult = results[0];
						if (firstResult.href) {
							window.location.href = firstResult.href;
						} else {
							firstResult.click();
						}
					}
					// Hide search results after selection
					searchResults.classList.add('hidden');
					searchResults.setAttribute('aria-expanded', 'false');
				}
			});

			// Handle navigation within search results using event delegation
			document.addEventListener('keydown', function(e) {
				// Only handle if we're focused on a search result
				if (!document.activeElement.classList.contains('search-result')) return;

				const results = Array.from(searchResults.querySelectorAll('.search-result[href]'));
				let currentIndex = -1;

				// Find current focused element index
				for (let i = 0; i < results.length; i++) {
					if (results[i] === document.activeElement) {
						currentIndex = i;
						break;
					}
				}

				if (e.key === 'ArrowDown') {
					e.preventDefault();
					const nextIndex = currentIndex < results.length - 1 ? currentIndex + 1 : 0;
					results[nextIndex].focus();
				} else if (e.key === 'ArrowUp') {
					e.preventDefault();
					if (currentIndex > 0) {
						results[currentIndex - 1].focus();
					} else {
						searchInput.focus();
					}
				} else if (e.key === 'Enter') {
					e.preventDefault();
					const focusedResult = document.activeElement;
					if (focusedResult.href) {
						window.location.href = focusedResult.href;
					} else {
						focusedResult.click();
					}
					searchResults.classList.add('hidden');
					searchResults.setAttribute('aria-expanded', 'false');
				} else if (e.key === 'Escape') {
					searchResults.classList.add('hidden');
					searchResults.setAttribute('aria-expanded', 'false');
					searchInput.focus();
				}
			});
		}
		
		document.addEventListener('DOMContentLoaded', initBreadcrumbSearch);
		document.body.addEventListener('htmx:afterSwap', initBreadcrumbSearch);
	</script>
}

templ legalFooter() {
	<footer style="background: var(--notion-bg); border-top: 1px solid var(--notion-border); margin-top: auto; padding: 1.5rem 0;">
		<div class="container" style="max-width: 1024px; text-align: center;">
			<p style="font-size: 12px; color: var(--notion-text-light); line-height: 1.4; margin: 0;">
				This work includes material from the System Reference Document 5.2.1 ("SRD 5.2.1") by Wizards of the Coast LLC, available at
				<a href="https://www.dndbeyond.com/srd" target="_blank" rel="noopener noreferrer" style="color: var(--notion-link);">https://www.dndbeyond.com/srd</a>.
				The SRD 5.2.1 is licensed under the Creative Commons Attribution 4.0 International License, available at
				<a href="https://creativecommons.org/licenses/by/4.0/legalcode" target="_blank" rel="noopener noreferrer" style="color: var(--notion-link);">https://creativecommons.org/licenses/by/4.0/legalcode</a>.
			</p>
		</div>
	</footer>
}